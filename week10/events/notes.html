<!DOCTYPE html>
<html>
   <head>
      <title>WDD 330 Portfolio</title>
   </head>

   <body>
   <script src="main.js"></script>
    <h1>Week 10 Notes</h1>
      <ul>
        <h2>MDN: Validating Forms</h2>
        <li><a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation">See article</a> for complete details<li>
        <li>Ensure all required form controls are filled out, in the correct format.</li>
        <li>Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away.</li>
        <li>Client-side validation should not be considered an exhaustive security measure! Your apps should always perform security checks on any form-submitted data on the server-side as well as the client-side, because client-side validation is too easy to bypass, so malicious users can still easily send bad data through to your server.</li>
        <br>
        <li>Reasons to validate forms on the client-side:</li>
        <ol>
          <li>Get the right data, in the right format.</li>
          <li>Protect users' data.</li>
          <li>Protect ourselves.</li>
        </ol>
        <br>
        <li>Types of Client-Side Validation:</li>
        <ol>
          <li><em>Built-in form validation</em> uses HTML5 form validation features, which we've discussed in many places throughout this module. This validation generally doesn't require much JavaScript. Built-in form validation has better performance than JavaScript, but it is not as customizable as JavaScript validation.</li>
          <li><em>JavaScript validation</em> is coded using JavaScript. This validation is completely customizable, but you need to create it all (or use a library).</li>
        </ol>
        <br>
        <h3>Using Built-In Form Validation</h3>
        <li>A signification feature of HTML5 form controls - Uses validation attributes on form elements</li>
        <ol>
          <li>required: Specifies whether a form field needs to be filled in before the form can be submitted.</li>
          <li>minlength and maxlength: Specifies the minimum and maximum length of textual data (strings)</li>
          <li>min and max: Specifies the minimum and maximum values of numerical input types</li>
          <li>type: Specifies whether the data needs to be a number, an email address, or some other specific preset type. </li>
          <li>pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.</li>
        </ol>
        <li>When an element is valid, the following things are true:</li>
        <ol>
          <li>The element matches the :valid CSS pseudo-class, which lets you apply a specific style to valid elements.</li>
          <li>If the user tries to send the data, the browser will submit the form, provided there is nothing else stopping it from doing so (e.g., JavaScript).</li>
        </ol>
         <li>Simple<a href = "/week10/events/fruitStart.html"> required attribute </a>example</li>
        <li>When an element is invalid, the following things are true:</li>
        <ol>
          <li>The element matches the :invalid CSS pseudo-class, and sometimes other UI pseudo-classes (e.g., :out-of-range) depending on the error, which lets you apply a specific style to invalid elements.</li>
          <li>If the user tries to send the data, the browser will block the form and display an error message.</li>
        </ol>
        <br>
        <li>Note: There are several errors that will prevent the form from being submitted, including a badInput, patternMismatch, rangeOverflow or rangeUnderflow, stepMismatch, tooLong or tooShort, typeMismatch, valueMissing, or a customError.<br></li>
         <h3>Validating Against a Regular Expression</h3>
         <li>Simple<a href = "/week10/events/fruitStart.html"> pattern attribute </a>example</li>
         <li>The <em>pattern</em> attribute -> expects a Regular Expression as its value</li>
        <li>A regular expression (regex) is a pattern that can be used to match character combinations in text strings, so regexs are ideal for form validation and serve a variety of other uses in JavaScript.</li>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">Regular Expressions</a> - microsoft guide<br></li>
         <h3>Constraining the Length of the Entries</h3>
        <li>Use the minlength and maxlength attributes.<br>A field is invalid if it has a value and that value has fewer characters than the minlength value or more than the maxlength value.</li>
         <h3>Constraining the Values of Entries</h3>
        <li>For number fields (i.e. <input type="number">), the min and max attributes can be used to provide a range of valid values. If the field contains a value outside this range, it will be invalid.</li>
         <li>Simple<a href = "/week10/events/fruitConstraint.html"> constraint attributes </a>example</li>
         <br>
         <h3>Validating Forms Using Javascript</h3>
        <li>You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation.<br></li>
         <h3>The Constraint Validation API</h3>
         <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Constraint_validation">This API</a> consists of a set of methods and properties available on the following form element DOM interfaces:</li>
         <ol>
            <li>HTMLButtonElement (represents a <button> element)</li>
            <li>HTMLFieldSetElement (represents a <fieldset> element)</li>
            <li>HTMLInputElement (represents an <input> element)</li>
            <li>HTMLOutputElement (represents an <output> element)</li>
            <li>HTMLSelectElement (represents a <select> element)</li>
            <li>HTMLTextAreaElement (represents a <textarea> element)</li>
         </ol>
        <li>It makes the following properties available on the above elements:</li>
         <ol>
            <li>validationMessage: Returns a localized message describing the validation constraints that the control doesn't satisfy (if any).</li>
            <li>validity: Returns a ValidityState object that contains several properties describing the validity state of the element.<br>Has several properties:</li>
            <ol>
               <li>patternMismatch: Returns true if the value does not match the specified pattern, and false if it does match.</li>
               <li>tooLong: Returns true if the value is longer than the maximum length specified by the maxlength attribute, or false if it is shorter than or equal to the maximum.</li>
               <li>tooShort: Returns true if the value is shorter than the minimum length specified by the minlength attribute, or false if it is greater than or equal to the minimum.</li>
               <li>rangeOverflow: Returns true if the value is greater than the maximum specified by the max attribute, or false if it is less than or equal to the maximum.</li>
               <li>rangeUnderflow: Returns true if the value is less than the minimum specified by the min attribute, or false if it is greater than or equal to the minimum.</li>
               <li>typeMismatch: Returns true if the value is not in the required syntax (when type is email or url), or false if the syntax is correct.</li>
               <li>valid: Returns true if the element meets all its validation constraints, and is therefore considered to be valid, or false if it fails any constraint.</li>
               <li>valueMissing: Returns true if the element has a required attribute, but no value, or false otherwise.</li>
            </ol>
            <li>willValidate: Returns true if the element will be validated when the form is submitted; false otherwise.</li>
         </ol>
         <br>
        <li>Implementing a customized error message:</li>
        <li>Customizing error messages is one of the most common use cases of the constraint validation API.</li>
         <li>See a <a href="/week10/events/customErrorMsg.html">custom error message</a> example.</li>
         <li>See a <a href="week10/events/fullCustomValidation.html">Full Example</a> - A detailed validation using Javascript</li>
         <br>
        <li>Validating forms without a built-in API:</li>
        <li>In some cases, such as legacy browser support or custom controls, you won't be able to or won't want to use the Constraint Validation API.You're still able to use JavaScript to validate your form, but you'll just have to write your own.</li>
         <ol>
            <li>What kind of validation should I perform?</li>
            <li>What should I do if the form doesn't validate?</li>
            <li>How can I help the user to correct invalid data?</li>
            <li>See <a href="week10/events/simpleJSValidation.html">this example</a> without using the constraint API.</li>
            <br>
            <h3>Summary:</h3>
           <li>Client-side form validation sometimes requires JavaScript if you want to customize styling and error messages, but it always requires you to think carefully about the user.</li>
           <li>Always remember to help your users correct the data they provide.</li>
           <li>Important:</li>
            <ol>
               <li>Display explicit error messages.</li>
               <li>Be permissive about the input format.</li>
               <li>Point out exactly where the error occurs, especially on large forms.</li>
            </ol>
           <br>
            <br>
            
        <h2>MDN: Using Fetch</h2>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">See article</a> for complete details<li>
        <li>XX</li>
        <li>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.</li>
        <li>It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.<br></li>
        <li>The fetch specification differs from jQuery.ajax() in three main ways:</li>
        <ol>
           <li>The Promise returned from fetch() <em>won’t reject on HTTP error status</em> even if the response is an HTTP 404 or 500. Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure or if anything prevented the request from completing.</li>
           <li>fetch() <em>can receive cross-site cookies</em>; you can establish a cross site session using fetch.</li>
           <li>fetch() <em>won’t send cookies</em>, unless you set the credentials init option.</li>
        </ol>
            <h3>Supplying request options</h3>
        <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings.</li>
            <li>See the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"> fetch() page</a> for complete info.</li>
        <li>Note that mode: "no-cors" only allows a limited set of headers in the request:</li>
         <ol>
          <li>Accept</li>
            <li>Accept-Language</li>
            <li>Content-Language</li>
            <li>Content-Type with a value of application/x-www-form-urlencoded, multipart/form-data, or text/plain</li>
        </ol>
        <h3>Sending a request with credentials included</h3>
        <li>To cause browsers to send a request with credentials included, even for a cross-origin call, add credentials: 'include' to the init object you pass to the fetch() method.</li>
            <li>See <a href="week10/events/fetch.js">this page for fetch() examples:</a></li>
            <ol>
          <li>Supplying request options</li>
               <li>Sending a request with credentials included</li>
               <li>Uploading JSON data</li>
               <li>Uploading a file</li>
               <li>Uploading multiple files</li>
               <li>Processing a text file line by line</li>
               <li>Checking that the fetch was successful</li>
               <li>Supplying your own request object</li>
               <li></li>
               <li></li>
               <li></li>
               <li></li>
        </ol>
            <h3>Headers</h3>
        <li>The Headers interface allows you to create your own headers object via the Headers() constructor.</li>
        <li>All of the Headers methods throw a TypeError if a header name is used that is not a valid HTTP Header name. <br>The mutation operations will throw a TypeError if there is an immutable guard (see below). Otherwise, they fail silently.</li>
        <li>A good use case for headers is checking whether the content type is correct before you process it further.</li>
            <li><em>Guard Property</em></li>
        <li>Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers objects have a guard property. <br>This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object.</li>
        <li>Possible guard values are:</li>
            <ol>
          <li>none: default</li>
               <li>request: guard for a headers object obtained from a request (Request.headers)</li>
               <li>request-no-cors: guard for a headers object obtained from a request created with Request.mode no-cors</li>
               <li>response: guard for a Headers obtained from a response (Response.headers)</li>
               <li>immutable: Mostly used for ServiceWorkers; renders a headers object read-only</li>
        </ol>
            <h3>Response objects</h3>
        <li>The most common response properties you'll use are:</li>
         <ol>
          <li>Response.status — An integer (default value 200) containing the response status code.</li>
            <li>Response.statusText — A string (default value "OK"), which corresponds to the HTTP status code message.</li>
            <li>Response.ok — seen in use above, this is a shorthand for checking that status is in the range 200-299 inclusive. This returns a Boolean.</li>
        </ol>
        <li>The Response() constructor takes two optional arguments — a body for the response, and an init object (similar to the one that Request() accepts.)</li>
            <h3>Body</h3>
        <li>Both requests and responses may contain body data. A body is an instance of any of the following types:</li>
        <ol>
          <li>ArrayBuffer</li>
           <li>ArrayBufferView (Uint8Array and friends)</li>
           <li>Blob/File</li>
           <li>string</li>
           <li>URLSearchParams</li>
           <li>FormData</li>
        </ol>
        <li>The Body mixin defines the following methods to extract a body (implemented by both Request and Response). These all return a promise that is eventually resolved with the actual content.</li>
        <ol>
          <li>ArrayBuffer</li>
           <li>blob()</li>
           <li>json()</li>
           <li>text()</li>
           <li>formData()</li>
        </ol>
         <li>Request bodies can be set by passing body parameters.</li>
        <li>Both request and response (and by extension the fetch() function), will try to intelligently determine the content type. A request will also automatically set a Content-Type header if none is set in the dictionary.</li>
            <li><em>Feature detection:</em> Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.</li>
            <li><em>Polyfill: </em>To use Fetch in unsupported browsers, there is a Fetch Polyfill available that recreates the functionality for non-supporting browsers.</li>
      </ul>
   </body>

</html>
