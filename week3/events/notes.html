<!DOCTYPE html>
<html>

   <head>
      <title>WDD 330 Portfolio | Notes</title>
   </head>

   <body>
   <script src="main.js"></script>

    <h1>Week 03 Notes</h1>
        <ol>
           <h2>Ch 5: Objects</h2>
           <li>Object: a self-contained set of related values and functions</li>
           <li>Object literal: an object that is created directly in the language by wrapping all its properties and methods in curly braces</li>
           <li>To create an object literal, simply enter a pair of curly braces. " const spiderman = {}; " It’s also possible to create an object using a constructor function. " const spiderman = new Object(); " - Not Recommended</li>
           <li>You can access the properties of an object using the dot notation (spiderman.name) or bracket notation (spiderman['name']).</li>
           <li>To call an object’s method we can also use dot or bracket notation.</li>
           <li>The in operator can be used to check whether an object has a particular property. Alternatively, you could also check to see if the property or method doesn’t return undefined.</li>
           <li>All objects have a method called hasOwnProperty() . This can be used to check whether an object has a property that is its own, rather than one that has been inherited from another object. This method willonlyreturn any properties that belong to that particular object.</li>
           <li>We can loop through all of an object’s properties and methods by using a for in loop.</li>  
           <ul>
            <li>Create an array with "key:property": for(const key in superman) {<br>    console.log(key + ": " + superman[key]);</li>
            <li>Create an array with "key:property" of ONLY the objects own properties: for(const key in superman) {<br>    if(superman.hasOwnProperty(key)){console.log(key + ": " + superman[key]);}}</li>
            <li>Create an array of all properties: for(const key of Object.keys(superman)) {console.log(key);}</li>
            <li>Create an array of all Object's values: for(const value of Object.values(superman)) {console.log(value);}</li>
            <li>Create an array of all Object's key:value pairs: for(const [key,value] of Object.entries(superman)) {console.log(`${key}: ${value}`);}</li>
           </ul>
           <li>JSON is a string representation of the object literal notation. Differences:</li>
           <ol>
            <li>Property names must be double-quoted</li>
            <li>Permitted values are double-quoted strings, numbers, true, false, null, arrays and objects</li>  
            <li>Functions are not permitted values</li>
           </ol>
           <li>JSON functions:</li>
           <ol>
            <li>parse() method: takes a string of data in JSON format and returns a JavaScript object</li>
            <li>stringify() method: takes a JavaScript object and returns a string of JSON data</li>  
           </ol>
           <li>Mathematical methods: abs(), ciel(), floor(), round(), trunc(), exp(), pow(), sqrt(), cbrt(), hypot(), plus log methods, trig methods, etc</li>
           <li>Epoch: 1st January 1970. This is an arbitrary date that is used in programming as a reference point in time from which to measure dates. </li>  
           <li>Constructor function: used to create a new date object (or other object) using the new operator</li>
           <li>GETTER and SETTER methods: can be called when new Objects are created from objects which already have established get and set methods</li>
           <li>Regular Expressions:</li>
           <ol>
              <li>More detailed information on <a ref=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#:~:text=Browser%20compatibility%20%20%20%20%20%20Desktop,No%20support%20No%20%202%20more%20rows%20>RegExp</a> at this link.</li> 
            <li>Set between forward slashes: const pattern = /[a-zA-Z]+ing$/; -> finds all words ending in 'ing'</li>
            <li>Use new operator and RegExp() method: const pattern = new RegExp('[a-zA-Z]+ing'); -> finds all words ending in 'ing'</li> 
            <li>Using literal regular expressions takes less typing, but there are advantages to using the constructor function as it lets you create regular expressions using strings, which can be useful when the regular expression is provided from user input</li>
            <li>test(): see if a string (passed to the method as a parameter) matches the regular expression pattern. It returns true if the pattern is in the string, and false if it isn’t.</li>
            <li>exec(): instead of returning true or false , it returns an array containing the first match found, or null if there aren’t any matches:</li>
            <li>The global property makes the pattern return all matches. By default, the pattern only looks for the first occurrence of a match. g sets the global property to true</li>
            <li>The ignoreCase property makes the pattern case-insensitive. By default, they are case sensitive. i sets the ignoreCase property to true</li>
            <li>The multiline property makes the pattern multiline. By default, a pattern will stop at the end of a line. m sets the multiline property to true</li>
            <li>. matches any character, except line breaks</li>
            <li>\w matches any word character, and is equivalent to [A-Za-z0-9_]</li>  
            <li>\W matches any non-word character, and is equivalent to [\^A-Za-z0-9_]</li>
            <li>\d matches any digit character, and is equivalent to [0-9]</li>
            <li>\D matches any non-digit character, and is equivalent to [^0-9]</li>
            <li>\s matches any whitespace character, and is equivalent to [ \t\r\n\f]</li>  
            <li>\S matches any non-whitespace character, and is equivalent to [^ \t\r\n\f]</li>
            <li>? makes the preceding token in the regular expression optional</li>
            <li>* matches one or more occurrences of the preceding token</li>
           <li>+ matches one or more occurrences of the preceding token</li>  
           <li>{n} matchesnoccurrences of the preceding token</li>
           <li>{n,} matches at leastnoccurrences of the pattern</li>
           <li>{,m} matches at mostmoccurrences of the preceding token</li>
           <li>{n,m} matches at leastnand at mostmoccurrences of the preceding token</li>  
           <li>^ marks the position immediately before the first character in the string</li>
           <li>$ marks the position immediately after the last character in the string</li>
           <li>Any special characters or modifiers can be escaped using a backslash. So if you wanted to match a question mark, ? , you would need to use the regular expression /\?/ .</li>
           </ol>
                      
           <h2>Ch 6: Document Object Model</h2>
           <li>The Document Object Model is a way of representing a page of HTML as a tree of nodes.</li>
           <li>Look at html page <a href="week3/events/heroes.html">heroes</a> Compare page to <a ref = https://d1rxzn6szs9jwr.cloudfront.net/premium/reeedr/books/javascript-novice-to-ninja-2nd-edition/images/ch6htmlTree.png>node tree</a></li>
           <li>The document.getElementById() , document.getElementsByClassName() , document.getElementsByTagNames() and document.querySelector() can be used to access elements on a page.</li>  
           <li>Every id attribute should be unique to just one element</li>
           <li>The parentNode() , previousSibling() , nextSibling() , childNodes() and children() methods can be used to navigate around the DOM tree.</li>
           <li>An element’s attributes can be accessed using the getAttribute() method, and updated using the setAttribute() method.</li>
           <li>The createElement() and createTextNode() methods can be used to create dynamic markup on the fly.</li>
           <li>Markup can be added to the page using the appendChild() and insertBefore() methods.</li>
           <li>Elements can be replaced using the replaceChild() method, and removed using the removeChild() method.</li>
           <li>The innerHTML property can be used to insert raw HTML directly into the DOM.</li>
           <li>The CSS properties of an element can be changed by accessing the style property.</li>
           
           <h2>Ch 7: Events</h2>
           <li>Events occur when a user interacts with a web page.</li>
           <li>An event listener is attached to an element, then invokes a callback function when the event occurs.</li>
           <ul>
              <li>document.body.addEventListener("click", doSomething);</li>
              <li>Inline: <p onclick="console.log('You Clicked Me!')">Click Me</p><em> - Not Recommended</em></li>
              <li>document.onclick = function (){ console.log('You clicked on the page!'); } - Only allows one function/event.</li>
           </ul>
           <li><a ref = https://developer.mozilla.org/en-US/docs/Web/Events>Full list of events.</a></li>
           <li>The event object is passed to the callback function as an argument, and contains lots of properties and methods relating to the event.</li>
           <li>There are many types of event, including mouse events, keyboard events, and touch events.</li>
           <li>You can remove an event using the removeEventListener method.</li>
           <li>The default behavior of elements can be prevented using the preventDefault() function.</li>
           <li>Event propagation is the order the events fire on each element.</li>
           <li>Event delegation is when an event listener is added to a parent element to capture events that happen to its children elements.</li>
           <li></li>
           <li></li>
        </ol>
      
   </body>

</html>
